{"version":3,"file":"sparky.js","sources":["../node_modules/nanoid/non-secure/index.js","../src/sparky.dom.ts","../src/sparky.eventmanager.ts","../node_modules/kind-of/index.js","../node_modules/is-plain-object/index.js","../node_modules/isobject/index.js","../node_modules/shallow-clone/index.js","../node_modules/clone-deep/index.js","../src/sparky.context.ts","../src/sparky.function.helper.ts","../src/sparky.helper.ts","../src/sparky.router.ts","../node_modules/requestidlecallback-polyfill/index.js","../src/sparky.function.ts","../src/sparky.ts","../src/sparky.component.ts","../src/sparky.event.ts","../src/sparky.ts"],"sourcesContent":["// This alphabet uses a-z A-Z 0-9 _- symbols.\n// Symbols are generated for smaller size.\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\nvar url = '-_'\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\nvar i = 36\nwhile (i--) {\n  // 36 is radix. Number.prototype.toString(36) returns number\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\n  url += i.toString(36)\n}\n// Loop from 36 to 10 (from Z to A in Base36).\ni = 36\nwhile (i-- - 10) {\n  url += i.toString(36).toUpperCase()\n}\n\n/**\n * Generate URL-friendly unique ID. This method use non-secure predictable\n * random generator with bigger collision probability.\n *\n * @param {number} [size=21] The number of symbols in ID.\n *\n * @return {string} Random string.\n *\n * @example\n * const nanoid = require('nanoid/non-secure')\n * model.id = nanoid() //=> \"Uakgb_J5m9g-0JDMbcJqL\"\n *\n * @name nonSecure\n * @function\n */\nmodule.exports = function (size) {\n  var id = ''\n  i = size || 21\n  // Compact alternative for `for (var i = 0; i < size; i++)`\n  while (i--) {\n    // `| 0` is compact and faster alternative for `Math.floor()`\n    id += url[Math.random() * 64 | 0]\n  }\n  return id\n}\n","import { HTMLElementSparkyEnhanced } from \"./sparky.component\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function reconciliate(currentDom: HTMLElement, nextDom: HTMLElement) {\r\n    if (!nextDom) return null;\r\n    if (!currentDom && nextDom) return nextDom;\r\n    if (currentDom.isEqualNode(nextDom)) return currentDom;\r\n    if (currentDom.nodeName !== nextDom.nodeName) return nextDom;\r\n\r\n    const domQueue: [Node, Node][] = [[currentDom, nextDom]];\r\n\r\n    while(domQueue.length > 0) {\r\n        const [currentElem, nextElem] = domQueue.shift();\r\n        const removedList: Node[] = [];\r\n        reconciliateAttribute(currentElem as HTMLElement, nextElem as HTMLElement);\r\n        \r\n        if(nextElem.nodeName != \"#text\" && (nextElem as HTMLElementSparkyEnhanced).__sparkyEvent) {\r\n            (currentElem as HTMLElementSparkyEnhanced).__sparkyEvent = \r\n                (nextElem as HTMLElementSparkyEnhanced).__sparkyEvent;\r\n        }\r\n\r\n        if(nextElem.nodeName != \"#text\" && (nextElem as HTMLElementSparkyEnhanced).__sparkyRoot) {\r\n            (currentElem as HTMLElementSparkyEnhanced).__sparkyRoot = \r\n                (nextElem as HTMLElementSparkyEnhanced).__sparkyRoot;\r\n        }\r\n\r\n        const nextElemChildren = nextElem.childNodes;\r\n        currentElem.childNodes.forEach((node, i) => {\r\n            const nextNode = nextElemChildren.item(i) as HTMLElementSparkyEnhanced;\r\n\r\n            if(!nextNode) {\r\n                removedList.push(node)\r\n                return;\r\n            }\r\n\r\n            if(node.isEqualNode(nextNode)) return;\r\n\r\n            if(node.isEqualNode(nextNode.nextElementSibling)) {\r\n                const newNextNode = nextNode.cloneNode(true);\r\n                const oldNextNode = nextNode.parentElement.replaceChild(newNextNode, nextNode);\r\n                node.parentNode.insertBefore(oldNextNode, node);\r\n                return;\r\n            }\r\n\r\n            if(node.nodeName !== nextNode.nodeName) {\r\n                const newNextNode = nextNode.cloneNode(true);\r\n                const oldNextNode = nextNode.parentElement.replaceChild(newNextNode, nextNode);\r\n                currentElem.replaceChild(oldNextNode, node);\r\n                return;\r\n            }\r\n\r\n            if(node.nodeName == \"#text\" && node.textContent !== nextNode.textContent) {\r\n                node.textContent = nextNode.textContent;\r\n                return;\r\n            }\r\n\r\n            domQueue.push([node, nextNode])\r\n        });\r\n\r\n        for(let i = currentElem.childNodes.length; i < nextElem.childNodes.length; i++) {\r\n            const childNode = nextElem.childNodes.item(i);\r\n            const newNextNode = childNode.cloneNode(true);\r\n\r\n            let oldNextNode: ChildNode = null;\r\n            // Internet Explorer 9/10/11 strange behavior\r\n            if(childNode.parentElement) {\r\n                oldNextNode = childNode.parentElement.replaceChild(newNextNode, childNode);\r\n                currentElem.appendChild(oldNextNode)\r\n            }\r\n        }\r\n\r\n        removedList.forEach((rmElem) => {\r\n            currentElem.removeChild(rmElem)\r\n        })\r\n\r\n    }\r\n\r\n    return currentDom;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction reconciliateAttribute(currentElem: HTMLElement, nextElem: HTMLElement) {\r\n    if(!currentElem.attributes || !nextElem.attributes) return;\r\n\r\n    const sortedCurrentAttributes = Array.from(currentElem.attributes).sort((attr, attr2) => attributeSort(attr, attr2))\r\n    const sortedNextAttributes = Array.from(nextElem.attributes).sort((attr, attr2) => attributeSort(attr, attr2))\r\n\r\n    const removedAttr: Attr[] = [];\r\n\r\n    sortedCurrentAttributes.forEach((attr, i) => {\r\n        const nextAttr = sortedNextAttributes[i];\r\n\r\n        if(!nextAttr) {\r\n            removedAttr.push(attr);\r\n            return;\r\n        }\r\n        \r\n        if(attr.name !== nextAttr.name) {\r\n            removedAttr.push(attr);\r\n            currentElem.setAttribute(nextAttr.name, nextAttr.value);\r\n            return;\r\n        }\r\n\r\n        if(attr.value !== nextAttr.value) {\r\n            attr.value = nextAttr.value;\r\n        }\r\n    })\r\n\r\n    for(let i = sortedCurrentAttributes.length; i < sortedNextAttributes.length; i++) {\r\n        const nextAttr = sortedNextAttributes[i];\r\n        currentElem.setAttribute(nextAttr.name, nextAttr.value);\r\n    }\r\n\r\n    removedAttr.forEach(attr => currentElem.removeAttribute(attr.name))\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction attributeSort(a: Attr, b: Attr) {\r\n    return (a.name < b.name ? -1 : (a.name > b.name ? 1 : 0));\r\n}\r\n","import { ISparkySelf } from \"./sparky.context\";\r\nimport { HTMLElementSparkyEnhanced } from \"./sparky.component\";\r\n\r\n/**\r\n * @internal\r\n */\r\ninterface windowTesting extends Window {\r\n    thisTestEvent: eventListSingle[]\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface eventListSingle {\r\n    dom: HTMLElement;\r\n    type: string;\r\n    context: ISparkySelf;\r\n    callbackFn: eventCallbackFn;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IEventSingle {\r\n    type: string;\r\n    context: ISparkySelf;\r\n    callbackFn: eventCallbackFn;\r\n}\r\n\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type eventCallbackFn = (evt: Event) => void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class EventManager {\r\n    static oldEventType: string[] = [];\r\n    static eventList: eventListSingle[] = [];\r\n    static eventListType: string[] = [];\r\n\r\n    static listen(finalDOM: HTMLElement) {\r\n        EventManager.removeAllEvents();\r\n        EventManager.populateEvents(finalDOM);\r\n        EventManager.removeUnusedEvents();\r\n        (window as unknown as windowTesting).thisTestEvent = EventManager.eventList;\r\n        this.eventList.forEach((event) => {\r\n            const { type } = event;\r\n            if(!this.isEventTypeListening(type)) {\r\n                document.addEventListener(type, (event) => this.dispatchEvent(event))\r\n                this.eventListType.push(type);\r\n            }\r\n        });\r\n    }\r\n\r\n    static dispatchEvent(event: Event) {\r\n        this.eventList.find((evtList) => {\r\n            if(this.isEventTarget(evtList, event)) {\r\n                if(evtList.type === event.type) {\r\n                    evtList.callbackFn(event);\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    static addEvent(eventSingle: eventListSingle) {\r\n        const {dom, type, context, callbackFn} = eventSingle;\r\n        this.eventList.push({ dom, type, context, callbackFn });\r\n    }\r\n\r\n    private static populateEvents(finalDOM: HTMLElementSparkyEnhanced) {\r\n        const domQueue = [finalDOM];\r\n        while(domQueue.length > 0) {\r\n            const elem = domQueue.shift();\r\n            \r\n            if(elem.__sparkyEvent) {\r\n                const { callbackFn, type, context } = elem.__sparkyEvent;\r\n                this.addEvent({dom: elem, type, context, callbackFn});\r\n            }\r\n    \r\n            for(let index = 0; index < elem.children.length; index++) {\r\n                domQueue.push(elem.children[index] as HTMLElement)\r\n            }\r\n        }\r\n    }\r\n\r\n    private static removeAllEvents() {\r\n        this.eventList = [];\r\n    }\r\n\r\n    private static removeUnusedEvents() {\r\n        this.eventList = this.eventList\r\n            .filter((evt) => evt.dom.isConnected);\r\n    }\r\n\r\n    private static isEventTypeListening(type: string) {\r\n        return this.eventListType.find(t => t == type);\r\n    }\r\n\r\n    private static isEventTarget(evtList: eventListSingle, event: Event) {\r\n        return (evtList.dom === event.target) || evtList.dom.contains(event.target as HTMLElement);\r\n    }\r\n}","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","/*!\n * shallow-clone <https://github.com/jonschlinkert/shallow-clone>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst valueOf = Symbol.prototype.valueOf;\nconst typeOf = require('kind-of');\n\nfunction clone(val, deep) {\n  switch (typeOf(val)) {\n    case 'array':\n      return val.slice();\n    case 'object':\n      return Object.assign({}, val);\n    case 'date':\n      return new val.constructor(Number(val));\n    case 'map':\n      return new Map(val);\n    case 'set':\n      return new Set(val);\n    case 'buffer':\n      return cloneBuffer(val);\n    case 'symbol':\n      return cloneSymbol(val);\n    case 'arraybuffer':\n      return cloneArrayBuffer(val);\n    case 'float32array':\n    case 'float64array':\n    case 'int16array':\n    case 'int32array':\n    case 'int8array':\n    case 'uint16array':\n    case 'uint32array':\n    case 'uint8clampedarray':\n    case 'uint8array':\n      return cloneTypedArray(val);\n    case 'regexp':\n      return cloneRegExp(val);\n    case 'error':\n      return Object.create(val);\n    default: {\n      return val;\n    }\n  }\n}\n\nfunction cloneRegExp(val) {\n  const flags = val.flags !== void 0 ? val.flags : (/\\w+$/.exec(val) || void 0);\n  const re = new val.constructor(val.source, flags);\n  re.lastIndex = val.lastIndex;\n  return re;\n}\n\nfunction cloneArrayBuffer(val) {\n  const res = new val.constructor(val.byteLength);\n  new Uint8Array(res).set(new Uint8Array(val));\n  return res;\n}\n\nfunction cloneTypedArray(val, deep) {\n  return new val.constructor(val.buffer, val.byteOffset, val.length);\n}\n\nfunction cloneBuffer(val) {\n  const len = val.length;\n  const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);\n  val.copy(buf);\n  return buf;\n}\n\nfunction cloneSymbol(val) {\n  return valueOf ? Object(valueOf.call(val)) : {};\n}\n\n/**\n * Expose `clone`\n */\n\nmodule.exports = clone;\n","'use strict';\n\n/**\n * Module dependenices\n */\n\nconst clone = require('shallow-clone');\nconst typeOf = require('kind-of');\nconst isPlainObject = require('is-plain-object');\n\nfunction cloneDeep(val, instanceClone) {\n  switch (typeOf(val)) {\n    case 'object':\n      return cloneObjectDeep(val, instanceClone);\n    case 'array':\n      return cloneArrayDeep(val, instanceClone);\n    default: {\n      return clone(val);\n    }\n  }\n}\n\nfunction cloneObjectDeep(val, instanceClone) {\n  if (typeof instanceClone === 'function') {\n    return instanceClone(val);\n  }\n  if (instanceClone || isPlainObject(val)) {\n    const res = new val.constructor();\n    for (let key in val) {\n      res[key] = cloneDeep(val[key], instanceClone);\n    }\n    return res;\n  }\n  return val;\n}\n\nfunction cloneArrayDeep(val, instanceClone) {\n  const res = new val.constructor(val.length);\n  for (let i = 0; i < val.length; i++) {\n    res[i] = cloneDeep(val[i], instanceClone);\n  }\n  return res;\n}\n\n/**\n * Expose `cloneDeep`\n */\n\nmodule.exports = cloneDeep;\n","import nanoid from \"nanoid/non-secure\";\r\nimport cloneDeep from \"clone-deep\";\r\nimport { ISparkyProps, ISparkyState, ISparkyComponent, IRenderReturn } from \"./sparky\";\r\nimport { IFnCached } from \"./sparky.function\";\r\nimport { HTMLElementSparkyEnhanced } from \"./sparky.component\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ISparkySelf {\r\n    props: ISparkyProps;\r\n    state?: ISparkyState;\r\n    cachedMemo?: IFnCached[],\r\n    cachedUpdate?: IFnCached[],\r\n    cachedState?: any[]\r\n    indexes?: {\r\n        memo: number;\r\n        update: number;\r\n        state: number;\r\n        [x: string] : number;\r\n    },\r\n    __id?: string,\r\n    __root?: ISparkyComponent,\r\n    __rootElement?: HTMLElementSparkyEnhanced\r\n    renderFunc: (props?: any) => IRenderReturn;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst emptyContext: ISparkySelf = {\r\n    __rootElement: null,\r\n    __root: null,\r\n    __id: \"\",\r\n    props: {},\r\n    state: {},\r\n    cachedMemo: [],\r\n    cachedUpdate: [],\r\n    cachedState: [],\r\n    indexes: {\r\n        memo: 0,\r\n        update: 0,\r\n        state: 0\r\n    },\r\n    renderFunc: null\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class SparkyContext {\r\n    private static __context: ISparkySelf\r\n    private static __defaultContext : ISparkySelf = emptyContext\r\n\r\n    public static getCurrentContext() {\r\n        return this.__context;\r\n    }\r\n\r\n    public static setCurrentContext(newContext: ISparkySelf) {\r\n        this.__context = newContext;\r\n    }\r\n\r\n    public static resetIndexes() {\r\n        if(!this.__context) throw new ReferenceError(\"Try to reset index on a undefined context\");\r\n        this.__context.indexes.memo = 0;\r\n        this.__context.indexes.update = 0;\r\n        this.__context.indexes.state = 0;\r\n    }\r\n\r\n    public static newContext(newContext: ISparkySelf) : ISparkySelf {\r\n        return cloneDeep({...this.__defaultContext, ...newContext, __id: nanoid(12)});\r\n    }\r\n}","import { arrayAreSame } from \"./sparky.helper\";\r\nimport { IFnCached, IArgumentsList } from \"./sparky.function\";\r\nimport { ISparkySelf } from \"./sparky.context\";\r\n\r\ntype ICachedType = \"memoize\" | \"update\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function callCachedFn(context: ISparkySelf, type: ICachedType, cachedArray: IFnCached[], callbackFn: Function, argumentsChanged?: IArgumentsList) {\r\n    const fnCached = cachedArray[getIndexByType(context, type)];\r\n\r\n    const newMemo = {\r\n        fn: callbackFn,\r\n        result: null,\r\n        dependencies: argumentsChanged\r\n    };\r\n\r\n    if (!fnCached) {\r\n        executeSanitizeFunction(fnCached, type);\r\n        newMemo.result = callbackFn.call(window, argumentsChanged ? [...argumentsChanged] : null);\r\n        cachedArray.push(newMemo)\r\n        return newMemo.result;\r\n    }\r\n\r\n    if (!argumentsChanged || !arrayAreSame(fnCached.dependencies, argumentsChanged)) {\r\n        executeSanitizeFunction(fnCached, type);\r\n        fnCached.dependencies = argumentsChanged;\r\n        fnCached.result = callbackFn.call(window, ...(argumentsChanged ? argumentsChanged : []));\r\n        return fnCached.result;\r\n    }\r\n\r\n    return fnCached.result;\r\n}\r\n\r\nfunction executeSanitizeFunction(fnCached: IFnCached, type: string) {\r\n    if (fnCached && fnCached.result) {\r\n        if (typeof fnCached.result == \"function\" && type == \"update\") {\r\n            fnCached.result();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction getIndexByType(context: ISparkySelf, type: ICachedType) {\r\n    if (type == \"memoize\")\r\n        return context.indexes.memo;\r\n    return context.indexes.update;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function incrementIndexByType(context: ISparkySelf, type: ICachedType) {\r\n    if (type == \"memoize\")\r\n        return ++context.indexes.memo;\r\n    return ++context.indexes.update;\r\n}","/**\r\n * @internal\r\n */\r\ninterface ISortArray {\r\n    bigArray: any[];\r\n    smallArray: any[];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function arrayAreSame(array1: any[], array2: any[]) {\r\n    if(!array1 || !array2) return false;\r\n    const { bigArray, smallArray } = sortArrayInObject(array1, array2);\r\n\r\n    return bigArray.every((big, i) => {\r\n        return big == (smallArray ? smallArray[i] : null);\r\n    })\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction sortArrayInObject(array1: any[], array2: any[]): ISortArray {\r\n    const length_1 = array1.length;\r\n    const length_2 = array2.length;\r\n\r\n    if(length_1 > length_2) return { bigArray: array1, smallArray: array2 }\r\n\r\n    return { bigArray: array2, smallArray: array1 }\r\n}","import { IStateRoute, Sparky, ISparkyComponent } from \"./sparky\"\r\nimport { HTMLElementSparkyEnhanced, ISparkyRoot, IParams } from \"./sparky.component\";\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTest;\r\nexport type IRoutingTypes = \"browser\" | \"hash\" | \"abstract\";\r\n/**\r\n * @internal\r\n */\r\nexport interface documentSparkyEnhanced extends Document {\r\n    __sparkyRoutingId: string;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function listeningHashChange(stateRoute: IStateRoute[], callbackFn: Function, dom: HTMLElementSparkyEnhanced) {\r\n    if(!dom.__sparkyRoot.isRoutingEnabled)\r\n        throw TypeError(\"To use route() function, you need to pass a Sparky.router object on the mount function\");\r\n    window.requestIdleCallback(() => {\r\n        window.addEventListener(\"hashchange\", (evt) => {\r\n            changeStateByEvent(evt, stateRoute, callbackFn, dom)\r\n        })\r\n    })\r\n    if(typeof thisTest != \"undefined\" && thisTest.testing) {\r\n        const evt = new Event(\"hashchange\") as HashChangeEvent;\r\n        Object.defineProperty(evt, 'oldUrl', {writable: false, value: \"\"});\r\n        Object.defineProperty(evt, 'newURL', {writable: true, value: \"#\"});\r\n        changeStateByEvent(evt, stateRoute, callbackFn, dom);\r\n        dom.__sparkyRoot.stateChanging = true;\r\n        dom.__sparkyRoot.basename = dom.__sparkyRoot.basename ? dom.__sparkyRoot.basename : \"\"; \r\n        dom.__sparkyRoot.forceURLUpdate = true;\r\n        changeStateByEvent(evt, stateRoute, callbackFn, dom)\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction changeStateByEvent(evt: HashChangeEvent, stateRoute: IStateRoute[], callbackFn: Function, dom: HTMLElementSparkyEnhanced) {\r\n    const documentSparky = document as documentSparkyEnhanced;\r\n\r\n    if(dom.__sparkyRoot.forceURLUpdate) \r\n        documentSparky.__sparkyRoutingId = dom.__sparkyRoot.id;\r\n\r\n    if(documentSparky.__sparkyRoutingId \r\n        && documentSparky.__sparkyRoutingId != dom.__sparkyRoot.id) {\r\n            console.warn(\"Only one route object can have the control of URL\")\r\n            return;\r\n        }\r\n    if(evt.oldURL == evt.newURL || dom.__sparkyRoot.stateChanging) {\r\n        dom.__sparkyRoot.stateChanging = false;\r\n        return;\r\n    };\r\n    const newState = getStateByHash(stateRoute, location.hash);\r\n    newState.hash = location.hash;\r\n    dom.__sparkyRoot.params = getParamsByPath(newState.path, location.hash);\r\n    pushToAbstractHistory(dom.__sparkyRoot, newState);\r\n    if(newState) {\r\n        resetUpdateCache(newState.component);\r\n        callbackFn(newState.component);\r\n    }\r\n    documentSparky.__sparkyRoutingId = dom.__sparkyRoot.id;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getStateByHash(stateRoute: IStateRoute[], newPath: string) {\r\n    return stateRoute.find((state, i) => {\r\n        if (typeof state.path == \"string\") {\r\n            state.exact = true;\r\n            return matchUrl(state.path, newPath);\r\n        }\r\n        return false;\r\n    }) || {...stateRoute[0], exact: false};\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function pushToAbstractHistory(sparkyRoot: ISparkyRoot, stateRoute: IStateRoute) {\r\n    if(sparkyRoot.historyIndex < (history.length - 1)) {\r\n        sparkyRoot.history = sparkyRoot.history.slice(0, sparkyRoot.historyIndex + 1)\r\n    }\r\n    sparkyRoot.history.push(stateRoute);\r\n    sparkyRoot.historyIndex = sparkyRoot.history.length - 1;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky_cleanHistory(this: HTMLElementSparkyEnhanced) {\r\n    this.__sparkyRoot.history = [];\r\n    this.__sparkyRoot.historyIndex = 0;\r\n    this.__sparkyRoot.stateChanging = true;\r\n    location.hash = \"\";\r\n} \r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__goToState(this: HTMLElementSparkyEnhanced, newPath: string) {\r\n    let { routing, type, basename } = this.__sparkyRoot;\r\n    const routeState = getStateByHash(routing, newPath);\r\n    routeState.hash = newPath;\r\n    if(routeState.exact)\r\n        this.__sparkyRoot.params = getParamsByPath(routeState.path, newPath);\r\n    this.__sparkyRoot.stateChanging = true;\r\n    let normalizePath = newPath;\r\n    switch(type) {\r\n        case \"hash\": location.hash = \"/\" + normalizePath; break;\r\n        case \"browser\": location.pathname = basename + \"/\" + normalizePath; break;\r\n    }\r\n    pushToAbstractHistory(this.__sparkyRoot, routeState);\r\n    resetUpdateCache(routeState.component);\r\n    Sparky.mount(routeState.component, this);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__back(this: HTMLElementSparkyEnhanced) {\r\n    let { history, type, basename } = this.__sparkyRoot;\r\n    if (this.__sparkyRoot.historyIndex - 1 < 0) return;\r\n    const state = history[--this.__sparkyRoot.historyIndex];\r\n    if(state.exact)\r\n        this.__sparkyRoot.params = getParamsByPath(state.path, state.hash);\r\n    this.__sparkyRoot.stateChanging = true;\r\n    let normalizePath = state.hash;\r\n    switch(type) {\r\n        case \"hash\": location.hash = \"/\" + normalizePath; break;\r\n        case \"browser\": location.pathname = basename + \"/\" + normalizePath; break;\r\n    }\r\n    resetUpdateCache(state.component);\r\n    Sparky.mount(state.component, this);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__forward(this: HTMLElementSparkyEnhanced) {\r\n    let { history, type, basename } = this.__sparkyRoot;\r\n    if (this.__sparkyRoot.historyIndex + 1 > history.length - 1) return; \r\n    const state = history[++this.__sparkyRoot.historyIndex];\r\n    if(state.exact)\r\n        this.__sparkyRoot.params = getParamsByPath(state.path, state.hash);\r\n    this.__sparkyRoot.stateChanging = true;\r\n    let normalizePath = state.hash;\r\n    switch(type) {\r\n        case \"hash\": location.hash = \"/\" + normalizePath; break;\r\n        case \"browser\": location.pathname = basename + \"/\" + normalizePath; break;\r\n    }\r\n    resetUpdateCache(state.component);\r\n    Sparky.mount(state.component, this)\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__params(this: HTMLElementSparkyEnhanced) {\r\n    const { params } = this.__sparkyRoot;\r\n    return params;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__currentState(this: HTMLElementSparkyEnhanced) {\r\n    const { history, historyIndex } = this.__sparkyRoot;\r\n    return history[historyIndex];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getParamsByPath(path:string, url: string): IParams[] {\r\n    if(path.includes(\"*\")) {  \r\n        const pathArray = path.split(\"*\");  \r\n        if(pathArray[1].includes(\"/\")) \r\n            throw TypeError(\"The wildcard can only be the last element to be identified on the url\");        \r\n    }\r\n    const urlParts = url.split(\"/\");\r\n    const params = [];\r\n    path.split(\"/\").reduce((params, pathPart, i) =>  {\r\n        if(pathPart.startsWith(\":\")) {\r\n            const obj = {};\r\n            obj[pathPart.slice(1, pathPart.length)] = urlParts[i];\r\n            params.push(obj as IParams);\r\n        } else if(pathPart.startsWith(\"*\")) {\r\n            const obj = {};\r\n            obj[pathPart.slice(1, pathPart.length)] = urlParts.slice(i, urlParts.length).join(\"\");\r\n            params.push(obj as IParams)\r\n        }\r\n        return params;\r\n    }, params);\r\n\r\n    return params;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function matchUrl(path:string, url: string) {\r\n    if(path.includes(\"*\")) {\r\n        const pathArray = path.split(\"*\");\r\n        if(pathArray[1].includes(\"/\")) \r\n            throw TypeError(\"The wildcard can only be the last element to be identified on the url\");        \r\n    }\r\n    const pathPart = path.split(\"/\").filter((part) => {\r\n        return !part.startsWith(\":\") && !part.startsWith(\"*\")\r\n    })\r\n\r\n    return url.includes(pathPart.join(\"/\"))\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function resetUpdateCache(component: ISparkyComponent) {\r\n    component.context.cachedUpdate = [];\r\n}","window.requestIdleCallback =\n    window.requestIdleCallback ||\n    function(cb) {\n        var start = Date.now();\n        return setTimeout(function() {\n            cb({\n                didTimeout: false,\n                timeRemaining: function() {\n                    return Math.max(0, 50 - (Date.now() - start));\n                },\n            });\n        }, 1);\n    };\n\nwindow.cancelIdleCallback =\n    window.cancelIdleCallback ||\n    function(id) {\n        clearTimeout(id);\n    };\n","import { Sparky, ISparkyStore } from \"./sparky\";\r\nimport 'requestidlecallback-polyfill';\r\nimport { callCachedFn, incrementIndexByType } from \"./sparky.function.helper\";\r\nimport { SparkyContext, ISparkySelf } from \"./sparky.context\";\r\nimport { Sparky__goToState, Sparky__back, Sparky__forward, Sparky_cleanHistory, Sparky__params, Sparky__currentState } from \"./sparky.router\";\r\nimport { IParams } from \"./sparky.component\";\r\n\r\nexport type ISetStateOrDispatcher<S> = (newStateOrAction: S | IDispatcherAction | INewStateFunction<S>) => void;\r\nexport type IArgumentsList = any[];\r\nexport type IDispatcherAction = { [x: string]: string | number | boolean | null | undefined};\r\ntype IUpdateCallback = () => void;\r\ntype INewStateFunction<S> = (prevState: S) => S;\r\ntype IBoundSetCurrentState = {\r\n    context: ISparkySelf;\r\n    state: number;\r\n    rootElement: HTMLElement;\r\n};\r\n\r\nexport interface IRouterFunctions {\r\n    /**\r\n     * Convenience method for transitioning to a new state.\r\n     * @params newPath to transitioning to that new state\r\n     */\r\n    goToState: (newPath: string) => void, \r\n    /**\r\n     * Convenience method for transitioning go back on history\r\n     */\r\n    goBack: () => void, \r\n    /**\r\n     * Convenience method for transitioning go forward on history\r\n     */\r\n    goAfter: () => void, \r\n    /**\r\n     * Returns an object of key/value pairs of parameters matched on the url\r\n     */\r\n    getParams: () => IParams[], \r\n    /**\r\n     * Convenience method to clean History stack\r\n     */\r\n    cleanHistory: () => void,\r\n    /**\r\n     * Get current state of the router\r\n     */\r\n    getCurrentState: () => void\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IFnCached {\r\n    fn: Function;\r\n    dependencies: string[];\r\n    result: any;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst getContext = () => {\r\n    const currentContext = SparkyContext.getCurrentContext();\r\n    if (!currentContext)\r\n        throw new ReferenceError(\"Sparky Function only can be used in the lifecycle of a Sparky application\");\r\n    return currentContext;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst setContext = (newContext: ISparkySelf) => {\r\n    SparkyContext.setCurrentContext(newContext);\r\n    SparkyContext.resetIndexes();\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst setCurrentState = function <S>(this: IBoundSetCurrentState, newState: S | ((prevState: S) => S) ) {\r\n    setContext(this.context);\r\n    const currentContext = getContext();\r\n    currentContext.indexes.state = this.state;\r\n    const prevState = currentContext.cachedState[currentContext.indexes.state];\r\n    currentContext.cachedState[currentContext.indexes.state] = \r\n        typeof(newState) == \"function\" ? (newState as INewStateFunction<S>)(prevState) : newState;\r\n    currentContext.indexes.state++;\r\n    if (currentContext.__root) {\r\n        SparkyContext.setCurrentContext(Sparky.mount({ \r\n            ...currentContext.__root, currentContext }, currentContext.__rootElement));\r\n    } else {\r\n        SparkyContext.setCurrentContext(\r\n            Sparky.mount({ type: \"SparkyComponent\", \r\n            context: currentContext, currentContext, renderFn: currentContext.renderFunc }, currentContext.__rootElement));\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst setInitialState = <S>(newState: S): ISetStateOrDispatcher<S> => {\r\n    const currentContext = getContext();\r\n    currentContext.cachedState[currentContext.indexes.state] = newState;\r\n    return setCurrentState;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__update = (callbackFn: IUpdateCallback, dependenciesChanged?: IArgumentsList) => {\r\n    const currentContext = getContext();\r\n    const indexes = {...currentContext.indexes};\r\n    incrementIndexByType(currentContext, \"update\");\r\n    window.requestIdleCallback(() => {\r\n        callCachedFn({...currentContext, indexes}, \"update\", currentContext.cachedUpdate, callbackFn, dependenciesChanged)\r\n    }, { timeout: 250 });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__state = <S>(initialState: S | ISparkyStore<S>): [S, ISetStateOrDispatcher<S>] => {\r\n    if(typeof(initialState) == \"object\") {\r\n        const initialStore = initialState as ISparkyStore<S>;\r\n        if(initialStore.type && initialStore.type == \"SparkyStore\") {\r\n            return Sparky__store(initialStore);\r\n        }\r\n    }\r\n    const currentContext = getContext();\r\n    const bound = { context: currentContext, state: currentContext.indexes.state }\r\n    const currentState = currentContext.cachedState[currentContext.indexes.state];\r\n    if(currentState) {\r\n        currentContext.indexes.state++;\r\n        const setState = setCurrentState;\r\n        return [currentState as S, setState.bind(bound)];\r\n    }\r\n    const setState = setInitialState(initialState);\r\n    currentContext.indexes.state++;\r\n    const lastIndex = currentContext.indexes.state - 1;\r\n    return [currentContext.cachedState[lastIndex] as S, setState.bind(bound)];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__memoize = (callbackFn: Function, argumentsChanged?: IArgumentsList) => {\r\n    const currentContext = getContext();\r\n    callCachedFn(currentContext, \"memoize\", currentContext.cachedMemo, callbackFn, argumentsChanged);\r\n    incrementIndexByType(currentContext, \"memoize\");\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__internal_history = () : IRouterFunctions => {\r\n    const currentContext = getContext();\r\n    if(!currentContext.__rootElement.__sparkyRoot.isRoutingEnabled)\r\n        throw TypeError(\"To use router() function, you need to pass a Sparky.router object on the mount function\");\r\n    const goToState = Sparky__goToState.bind(currentContext.__rootElement);\r\n    const goBack = Sparky__back.bind(currentContext.__rootElement);\r\n    const goAfter = Sparky__forward.bind(currentContext.__rootElement);\r\n    const getParams = Sparky__params.bind(currentContext.__rootElement);\r\n    const cleanHistory = Sparky_cleanHistory.bind(currentContext.__rootElement);\r\n    const getCurrentState = Sparky__currentState.bind(currentContext.__rootElement);\r\n\r\n    return { goToState, goBack, goAfter, getParams, cleanHistory, getCurrentState };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__store = <T>(store: ISparkyStore<T>): [T, (action: IDispatcherAction) => void] => {\r\n    return [store.store, (action: IDispatcherAction) => store.dispatcher(store, action)];\r\n}","import nanoid from \"nanoid/non-secure\";\r\n\r\nimport { reconciliate } from \"./sparky.dom\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { SparkyComponent, HTMLElementSparkyEnhanced, IParams } from \"./sparky.component\";\r\nimport { SparkyContext, ISparkySelf } from \"./sparky.context\";\r\n\r\nimport cloneDeep from \"clone-deep\";\r\n\r\nimport { Sparky__state, Sparky__update, Sparky__memoize, Sparky__internal_history, Sparky__store, IDispatcherAction } from \"./sparky.function\";\r\nimport { listeningHashChange, getStateByHash, getParamsByPath } from \"./sparky.router\";\r\n\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTest;\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTestEvent;\r\n\r\nexport interface IRenderReturn {\r\n    type: string;\r\n    html: string;\r\n    func: ISparkyEventFunc[],\r\n    nestedComponents: ISparkyComponent[];\r\n    children: IRenderReturn[];\r\n    renderId: string;\r\n}\r\n\r\nexport interface IStateRoute {\r\n    hash?: string;\r\n    exact?: boolean;\r\n    path: string;\r\n    component: ISparkyComponent;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IReconciliateProps {\r\n    dom: HTMLElement,\r\n    func: ISparkyEventFunc[],\r\n}\r\n\r\nexport type ISparkyFunction = (props?: any) => IRenderReturn;\r\n\r\nexport interface ISparkyEventFunc {\r\n    renderId: string;\r\n    index: number;\r\n    func: Function;\r\n}\r\n\r\nexport interface ISparkyComponent {\r\n    type: string;\r\n    context: ISparkySelf;\r\n    currentContext: ISparkySelf;\r\n    renderFn: ISparkyFunction;\r\n}\r\n\r\nexport interface ISparkyRouterOptions {\r\n    type?: \"hash\" | \"abstract\" | \"browser\";\r\n    basename?: string;\r\n    forceUrlUpdate?: boolean;\r\n}\r\n\r\nexport interface ISparkyRouter {\r\n    type: string;\r\n    component: ISparkyComponent;\r\n    routing: IStateRoute[];\r\n    history: IStateRoute[];\r\n    params: IParams[];\r\n    options: ISparkyRouterOptions;\r\n}\r\n\r\nexport type ISparkyStore<T> = {store: T, dispatcher : (store: ISparkyStore<T>, action: IDispatcherAction) => void, type: string}\r\n\r\nexport interface ISparkyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport type ISparkyState = ISparkyProps;\r\n\r\nexport class Sparky {\r\n\r\n    /**\r\n     * Generate a Sparky Component that can be mount.\r\n     * @param renderFunc The function that going to be execute to render html template\r\n     */\r\n    static component(renderFunc: ISparkyFunction, props?: ISparkyProps) {\r\n        const sparkyContext = SparkyContext.newContext({ props, renderFunc });\r\n        return { type: \"SparkyComponent\", context: sparkyContext, currentContext: sparkyContext, renderFn: renderFunc } as ISparkyComponent;\r\n    }\r\n\r\n    /**\r\n     * Create a routing component that manage history\r\n     * @param stateRoute \r\n     */\r\n    static router(stateRoute: IStateRoute[], options?: ISparkyRouterOptions): ISparkyRouter {\r\n        if(!options) options = { type: \"hash\" };\r\n        let locationString = \"\";\r\n        if(options.type == \"hash\") {\r\n            locationString = location.hash.slice(2, location.hash.length);\r\n        } else if (options.type == \"browser\") {\r\n            locationString = location.pathname;\r\n        }\r\n        const routeState = getStateByHash(stateRoute, locationString);\r\n        routeState.hash = locationString;\r\n        let params = []\r\n        if(routeState.exact)\r\n            params = getParamsByPath(routeState.path, locationString);\r\n        return { type: \"SparkyRouter\", component: routeState.component, routing: stateRoute, history: [routeState], params, options };\r\n    }\r\n\r\n    /**\r\n     * Mount a Sparky Component in the DOM Tree and keep it updated.\r\n     * @param component Sparky Component\r\n     * @param dom The dom element where you want to mount this component\r\n     */\r\n    static mount(element: ISparkyComponent | ISparkyRouter, dom: HTMLElementSparkyEnhanced): ISparkySelf {\r\n        const processEnvNode = createProcessIfNotExist();\r\n        if (processEnvNode === 'development')\r\n            console.time();\r\n        \r\n        const component = ((element.type == \"SparkyComponent\") ? element : (element as ISparkyRouter).component) as ISparkyComponent \r\n\r\n        initialiseDOM(dom, element);\r\n\r\n        const { context, renderFn } = component;\r\n\r\n        const keepIndexes = cloneDeep(component.currentContext.indexes);\r\n\r\n        context.__rootElement = dom; \r\n        SparkyContext.setCurrentContext(context);\r\n        SparkyContext.resetIndexes();\r\n\r\n        const render = renderFn(Object.freeze(context.props)) as IRenderReturn;\r\n\r\n        const oldDom = dom.__sparkyRoot.updateAt ? (dom.firstElementChild as HTMLElementSparkyEnhanced) : null;\r\n        let nextDOM = renderToDOMNode(render.html);\r\n\r\n        nextDOM = SparkyComponent.populate(nextDOM, render, component);\r\n\r\n\r\n        let finalDOM = reconciliate(oldDom, nextDOM);\r\n        if (!finalDOM) return;\r\n        if (!finalDOM.isConnected && dom)\r\n            dom.appendChild(finalDOM);\r\n\r\n        dom.__sparkyRoot.updateAt = new Date().getTime();\r\n\r\n        EventManager.listen(finalDOM);\r\n\r\n        if (processEnvNode === 'development')\r\n            console.timeEnd();\r\n\r\n        if(typeof thisTest != \"undefined\" && thisTest.testing) {\r\n            thisTest.__testUtilData = {\r\n                root: dom,\r\n                component,\r\n                eventList: thisTestEvent\r\n            };\r\n        }\r\n        \r\n        return {...component.currentContext, indexes: keepIndexes};\r\n    }\r\n\r\n    /**\r\n     * Create a Store to using it on components\r\n     * @param newStore Object that will be Store\r\n     * @param dispatcher Function that will run for changing programatically store object\r\n     */\r\n    static createStore<S>(newStore: S, dispatcher: (state: S, action: IDispatcherAction) => S): ISparkyStore<S> {\r\n        return {\r\n            type: \"SparkyStore\",\r\n            store: newStore,\r\n            dispatcher: (store, action) => { store.store = dispatcher(store.store, action) }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Reconciliate the current DOM with the new DOM Node\r\n     * @internal\r\n     * @param oldNode Node that need to be reconcile\r\n     * @param newNode Node that have the new elements\r\n     */\r\n    static reconciliate(oldNode: HTMLElement, newNode: HTMLElement) {\r\n        return reconciliate(oldNode, newNode)\r\n    }\r\n}\r\n\r\nfunction createProcessIfNotExist() {\r\n    if(typeof process !== \"undefined\" && process.env) {\r\n        return process.env.NODE_ENV;\r\n    };\r\n    return \"production\";\r\n}\r\n\r\n/**\r\n * Function will be run after the render is commited to the screen.\r\n * @param callbackFn - The function to run\r\n * @param dependenciesChanged - Array of values that the function depends on\r\n */\r\nexport const update = Sparky__update;\r\n\r\n/**\r\n * Returns a stateful value, and a function to update it.\r\n * @param initialState The value during the first render\r\n */\r\nexport const state = Sparky__state;\r\n\r\n/**\r\n * Run and returns a memoized value\r\n * @param callbackFn - Function will be run on rendering phase\r\n * @param argumentsChanged - Array of values that the function depends on\r\n */\r\nexport const memoize = Sparky__memoize;\r\n\r\n/**\r\n * Returns routing functions for current mounted component\r\n */\r\nexport const router = Sparky__internal_history;\r\n\r\n/**\r\n * Render the html string template to HTML elements\r\n * @param html Array of HTML String \r\n * @param computedProps Computed Props used to pass Javascript into template\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\r\n */\r\nexport function html(html: TemplateStringsArray | string, ...computedProps: any[]): IRenderReturn {\r\n    const func: ISparkyEventFunc[] = [];\r\n    const nestedComponents: ISparkyComponent[] = [];\r\n    const children: IRenderReturn[] = [];\r\n    const renderId = nanoid(12);\r\n\r\n    const newHTML = (typeof html == \"string\") ? html\r\n        : html.map((stringHTML, i) => {\r\n            let htmlLine = \"\"\r\n            htmlLine += stringHTML\r\n            if (!computedProps[i]) return htmlLine;\r\n            htmlLine = getComputedValue(computedProps, i, func, htmlLine, nestedComponents, children, renderId);\r\n            return htmlLine;\r\n        })\r\n\r\n    const innerHTML = Array.isArray(newHTML) ? newHTML.join(\"\") : newHTML;\r\n\r\n    return { type: \"SparkyRender\", html: innerHTML, func, nestedComponents, children, renderId };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param computedProps \r\n * @param i \r\n * @param func \r\n * @param htmlLine \r\n * @param nestedComponents \r\n * @param children \r\n * @param renderId \r\n */\r\nfunction getComputedValue(computedProps: any[], i: number, func: ISparkyEventFunc[], htmlLine: string, nestedComponents: ISparkyComponent[], children: IRenderReturn[], renderId: string) {\r\n    if (typeof computedProps[i] == \"function\") {\r\n        func.push({ index: func.length - 1, renderId, func: computedProps[i] });\r\n        htmlLine += `'SparkyFunction#${renderId}#${func.length - 1}'`;\r\n    }\r\n    else if (computedProps[i].type == \"SparkyRender\") {\r\n        const render = computedProps[i] as IRenderReturn;\r\n        htmlLine += render.html;\r\n        children.push(render)\r\n    }\r\n    else if (computedProps[i].type == \"SparkyComponent\") {\r\n        const comp = computedProps[i] as ISparkyComponent;\r\n        htmlLine += `<!-- SparkyComponent#${comp.renderFn.name}#${nestedComponents.length}#${renderId} -->`;\r\n        nestedComponents.push(comp);\r\n    }\r\n    else {\r\n        computedProps[i] = Array.isArray(computedProps[i]) ?\r\n            computedProps[i].join(\"\") : new String(computedProps[i]);\r\n        htmlLine += computedProps[i];\r\n    }\r\n    return htmlLine;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param dom \r\n * @param element \r\n */\r\nfunction initialiseDOM(dom: HTMLElementSparkyEnhanced, element: ISparkyComponent | ISparkyRouter) {\r\n    if (dom && !dom.__sparkyRoot) {\r\n        setRootProperties(dom);\r\n        if (element.type == \"SparkyRouter\") {\r\n            const { history, routing, params, options } = element as ISparkyRouter;\r\n            dom.__sparkyRoot = { ...dom.__sparkyRoot, history, \r\n                routing, params, \r\n                basename: options?.basename, \r\n                isRoutingEnabled: true,\r\n                forceURLUpdate: options?.forceUrlUpdate,\r\n                type: options?.type\r\n            };\r\n            if(dom.__sparkyRoot.type == \"hash\") {\r\n                listeningHashChange(routing, (component) => {\r\n                    Sparky.mount(component, dom);\r\n                }, dom);                \r\n            }\r\n        }\r\n    }\r\n    ;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param dom \r\n */\r\nfunction setRootProperties(dom: HTMLElementSparkyEnhanced) {\r\n    dom.__sparkyRoot = { \r\n        id: nanoid(12),\r\n        isRoutingEnabled: false,\r\n        basename: \"\",\r\n        params: [],\r\n        forceURLUpdate: false,\r\n        type: \"hash\",\r\n        historyIndex: 0,\r\n        stateChanging: false,\r\n        history: [],\r\n        routing: [],\r\n        updateAt: null\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param html \r\n */\r\nexport function renderToDOMNode(html: string) {\r\n    const div = document.createElement(\"div\");\r\n    div.innerHTML = html;\r\n    if (div.children.length > 1) {\r\n        throw new TypeError(\"Adjacent elements on the root level are forbidden.\");\r\n    }\r\n    return div.firstElementChild as HTMLElement;\r\n}","import { IRenderReturn, ISparkyComponent, renderToDOMNode, IStateRoute } from \"./sparky\";\r\nimport { findEvent } from \"./sparky.event\";\r\nimport { eventCallbackFn, IEventSingle } from \"./sparky.eventmanager\";\r\nimport { SparkyContext } from \"./sparky.context\";\r\nimport { IRoutingTypes } from \"./sparky.router\";\r\n\r\nexport interface IParams {\r\n    [x: string]: string\r\n}\r\nexport interface ISparkyRoot {\r\n    id: string;\r\n    isRoutingEnabled: boolean;\r\n    type: IRoutingTypes;\r\n    basename: string;\r\n    forceURLUpdate: boolean;\r\n    historyIndex: number;\r\n    stateChanging: boolean;\r\n    params: IParams[];\r\n    history: IStateRoute[];\r\n    routing: IStateRoute[];\r\n    updateAt: number;\r\n}\r\n\r\nexport interface HTMLElementSparkyEnhanced extends HTMLElement {\r\n    __sparkyEvent?: IEventSingle;\r\n    __sparkyRoot?: ISparkyRoot;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\ninterface ICachedComponent {\r\n    component: ISparkyComponent,\r\n    dom: HTMLElement\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class SparkyComponent {\r\n    private static cachedComponent: ICachedComponent[][] = [];\r\n    static populate(nextDOM: HTMLElement, render: IRenderReturn, rootComponent: ISparkyComponent) {\r\n        \r\n        const renderQueue: [IRenderReturn, ISparkyComponent, HTMLElement][] = [[render, rootComponent, nextDOM]];\r\n\r\n        let depthHorizontal = 0;\r\n\r\n        while (renderQueue.length > 0) {\r\n            const [currentRender, currentComponent, currentDOM] = renderQueue.shift();\r\n            if(!this.cachedComponent[depthHorizontal]) this.cachedComponent[depthHorizontal] = [];\r\n\r\n            currentRender.func.forEach((currentFunc, index) => {\r\n                const currentEvent = findEvent(currentDOM, currentRender.renderId, index);\r\n                const eventName = currentEvent.attr.name.replace(\"on\", \"\");\r\n                currentEvent.dom.__sparkyEvent = {\r\n                    type: eventName,\r\n                    context: currentComponent.context,\r\n                    callbackFn: currentFunc.func as eventCallbackFn\r\n                };\r\n                currentEvent.dom.removeAttribute(currentEvent.attr.name)\r\n            })\r\n\r\n            currentRender.children.forEach((currentChild) => {\r\n                renderQueue.push([currentChild, currentComponent, currentDOM])\r\n            })\r\n\r\n            currentRender.nestedComponents.forEach((currentComp, index) => {\r\n                const cached = this.cachedComponent[depthHorizontal][index];\r\n                const commentDom = this.findComment(currentDOM, currentRender.renderId, index, currentComp.renderFn.name);\r\n                if(cached) {\r\n                    if(cached.component.renderFn.name == \"\") {\r\n                        if(cached.component.renderFn.toString() == currentComp.renderFn.toString()) {\r\n                            currentComp = getCachedComponent(cached, currentComp);\r\n                        }\r\n                    } else if(cached.component.renderFn.name == currentComp.renderFn.name){\r\n                        currentComp = getCachedComponent(cached, currentComp);\r\n                    }\r\n                }\r\n                SparkyContext.setCurrentContext(currentComp.context);\r\n                SparkyContext.resetIndexes();\r\n                currentComp.context.__root = rootComponent;\r\n                currentComp.context.__rootElement = rootComponent.context.__rootElement;\r\n                const renderChild = currentComp.renderFn(Object.freeze(currentComp.context.props));\r\n                if(!commentDom) return;\r\n                const renderChildDOM = renderToDOMNode(renderChild.html);\r\n                commentDom.parentNode.replaceChild(renderChildDOM, commentDom);\r\n                render.func.push(...renderChild.func);\r\n                renderQueue.push([renderChild, currentComp, renderChildDOM]);\r\n\r\n                this.cachedComponent[depthHorizontal][index] = {\r\n                    component: currentComp,\r\n                    dom: currentDOM\r\n                };\r\n            });\r\n            if(currentRender.nestedComponents.length > 0)\r\n                depthHorizontal++;\r\n        }\r\n        \r\n        return nextDOM;\r\n    }\r\n\r\n    private static findComment(element: HTMLElement, renderId: string, i: number, componentName: string) {\r\n        const domQueue = [element];\r\n        while(domQueue.length > 0) {\r\n            const elem = domQueue.shift();\r\n            if(elem.nodeName == '#comment' && elem.nodeValue.trim() == `SparkyComponent#${componentName}#${i}#${renderId}`) {\r\n                return elem;\r\n            }\r\n\r\n            for(let i = 0; i < elem.childNodes.length; i++) {\r\n                domQueue.push(elem.childNodes[i] as HTMLElement);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction getCachedComponent(cached: ICachedComponent, currentComp: ISparkyComponent) {\r\n    cached.component.context.props = currentComp.context.props;\r\n    currentComp = cached.component;\r\n    return currentComp;\r\n}\r\n","import { HTMLElementSparkyEnhanced } from './sparky.component';\r\n\r\n/**\r\n * @internal\r\n */\r\ninterface IEventReturn {\r\n    dom: HTMLElementSparkyEnhanced;\r\n    attr: Attr;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function findEvent(element: HTMLElement, renderId: string, index: number) : IEventReturn {\r\n    const domQueue = [element];\r\n    while(domQueue.length > 0) {\r\n        const elem = domQueue.shift();\r\n        const eventAttr = Array.from(elem.attributes).find((attr) => {\r\n            if(attr.name.startsWith(\"on\")) {\r\n                return attr.value == `SparkyFunction#${renderId}#${index}`;\r\n            }\r\n        })\r\n\r\n        if(eventAttr) return {dom: elem, attr: eventAttr};\r\n\r\n        for(let index = 0; index < elem.children.length; index++) {\r\n            domQueue.push(elem.children[index] as HTMLElement)\r\n        }\r\n    }\r\n}","import nanoid from \"nanoid/non-secure\";\r\n\r\nimport { reconciliate } from \"./sparky.dom\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { SparkyComponent, HTMLElementSparkyEnhanced, IParams } from \"./sparky.component\";\r\nimport { SparkyContext, ISparkySelf } from \"./sparky.context\";\r\n\r\nimport cloneDeep from \"clone-deep\";\r\n\r\nimport { Sparky__state, Sparky__update, Sparky__memoize, Sparky__internal_history, Sparky__store, IDispatcherAction } from \"./sparky.function\";\r\nimport { listeningHashChange, getStateByHash, getParamsByPath } from \"./sparky.router\";\r\n\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTest;\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTestEvent;\r\n\r\nexport interface IRenderReturn {\r\n    type: string;\r\n    html: string;\r\n    func: ISparkyEventFunc[],\r\n    nestedComponents: ISparkyComponent[];\r\n    children: IRenderReturn[];\r\n    renderId: string;\r\n}\r\n\r\nexport interface IStateRoute {\r\n    hash?: string;\r\n    exact?: boolean;\r\n    path: string;\r\n    component: ISparkyComponent;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IReconciliateProps {\r\n    dom: HTMLElement,\r\n    func: ISparkyEventFunc[],\r\n}\r\n\r\nexport type ISparkyFunction = (props?: any) => IRenderReturn;\r\n\r\nexport interface ISparkyEventFunc {\r\n    renderId: string;\r\n    index: number;\r\n    func: Function;\r\n}\r\n\r\nexport interface ISparkyComponent {\r\n    type: string;\r\n    context: ISparkySelf;\r\n    currentContext: ISparkySelf;\r\n    renderFn: ISparkyFunction;\r\n}\r\n\r\nexport interface ISparkyRouterOptions {\r\n    type?: \"hash\" | \"abstract\" | \"browser\";\r\n    basename?: string;\r\n    forceUrlUpdate?: boolean;\r\n}\r\n\r\nexport interface ISparkyRouter {\r\n    type: string;\r\n    component: ISparkyComponent;\r\n    routing: IStateRoute[];\r\n    history: IStateRoute[];\r\n    params: IParams[];\r\n    options: ISparkyRouterOptions;\r\n}\r\n\r\nexport type ISparkyStore<T> = {store: T, dispatcher : (store: ISparkyStore<T>, action: IDispatcherAction) => void, type: string}\r\n\r\nexport interface ISparkyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport type ISparkyState = ISparkyProps;\r\n\r\nexport class Sparky {\r\n\r\n    /**\r\n     * Generate a Sparky Component that can be mount.\r\n     * @param renderFunc The function that going to be execute to render html template\r\n     */\r\n    static component(renderFunc: ISparkyFunction, props?: ISparkyProps) {\r\n        const sparkyContext = SparkyContext.newContext({ props, renderFunc });\r\n        return { type: \"SparkyComponent\", context: sparkyContext, currentContext: sparkyContext, renderFn: renderFunc } as ISparkyComponent;\r\n    }\r\n\r\n    /**\r\n     * Create a routing component that manage history\r\n     * @param stateRoute \r\n     */\r\n    static router(stateRoute: IStateRoute[], options?: ISparkyRouterOptions): ISparkyRouter {\r\n        if(!options) options = { type: \"hash\" };\r\n        let locationString = \"\";\r\n        if(options.type == \"hash\") {\r\n            locationString = location.hash.slice(2, location.hash.length);\r\n        } else if (options.type == \"browser\") {\r\n            locationString = location.pathname;\r\n        }\r\n        const routeState = getStateByHash(stateRoute, locationString);\r\n        routeState.hash = locationString;\r\n        let params = []\r\n        if(routeState.exact)\r\n            params = getParamsByPath(routeState.path, locationString);\r\n        return { type: \"SparkyRouter\", component: routeState.component, routing: stateRoute, history: [routeState], params, options };\r\n    }\r\n\r\n    /**\r\n     * Mount a Sparky Component in the DOM Tree and keep it updated.\r\n     * @param component Sparky Component\r\n     * @param dom The dom element where you want to mount this component\r\n     */\r\n    static mount(element: ISparkyComponent | ISparkyRouter, dom: HTMLElementSparkyEnhanced): ISparkySelf {\r\n        const processEnvNode = createProcessIfNotExist();\r\n        if (processEnvNode === 'development')\r\n            console.time();\r\n        \r\n        const component = ((element.type == \"SparkyComponent\") ? element : (element as ISparkyRouter).component) as ISparkyComponent \r\n\r\n        initialiseDOM(dom, element);\r\n\r\n        const { context, renderFn } = component;\r\n\r\n        const keepIndexes = cloneDeep(component.currentContext.indexes);\r\n\r\n        context.__rootElement = dom; \r\n        SparkyContext.setCurrentContext(context);\r\n        SparkyContext.resetIndexes();\r\n\r\n        const render = renderFn(Object.freeze(context.props)) as IRenderReturn;\r\n\r\n        const oldDom = dom.__sparkyRoot.updateAt ? (dom.firstElementChild as HTMLElementSparkyEnhanced) : null;\r\n        let nextDOM = renderToDOMNode(render.html);\r\n\r\n        nextDOM = SparkyComponent.populate(nextDOM, render, component);\r\n\r\n\r\n        let finalDOM = reconciliate(oldDom, nextDOM);\r\n        if (!finalDOM) return;\r\n        if (!finalDOM.isConnected && dom)\r\n            dom.appendChild(finalDOM);\r\n\r\n        dom.__sparkyRoot.updateAt = new Date().getTime();\r\n\r\n        EventManager.listen(finalDOM);\r\n\r\n        if (processEnvNode === 'development')\r\n            console.timeEnd();\r\n\r\n        if(typeof thisTest != \"undefined\" && thisTest.testing) {\r\n            thisTest.__testUtilData = {\r\n                root: dom,\r\n                component,\r\n                eventList: thisTestEvent\r\n            };\r\n        }\r\n        \r\n        return {...component.currentContext, indexes: keepIndexes};\r\n    }\r\n\r\n    /**\r\n     * Create a Store to using it on components\r\n     * @param newStore Object that will be Store\r\n     * @param dispatcher Function that will run for changing programatically store object\r\n     */\r\n    static createStore<S>(newStore: S, dispatcher: (state: S, action: IDispatcherAction) => S): ISparkyStore<S> {\r\n        return {\r\n            type: \"SparkyStore\",\r\n            store: newStore,\r\n            dispatcher: (store, action) => { store.store = dispatcher(store.store, action) }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Reconciliate the current DOM with the new DOM Node\r\n     * @internal\r\n     * @param oldNode Node that need to be reconcile\r\n     * @param newNode Node that have the new elements\r\n     */\r\n    static reconciliate(oldNode: HTMLElement, newNode: HTMLElement) {\r\n        return reconciliate(oldNode, newNode)\r\n    }\r\n}\r\n\r\nfunction createProcessIfNotExist() {\r\n    if(typeof process !== \"undefined\" && process.env) {\r\n        return process.env.NODE_ENV;\r\n    };\r\n    return \"production\";\r\n}\r\n\r\n/**\r\n * Function will be run after the render is commited to the screen.\r\n * @param callbackFn - The function to run\r\n * @param dependenciesChanged - Array of values that the function depends on\r\n */\r\nexport const update = Sparky__update;\r\n\r\n/**\r\n * Returns a stateful value, and a function to update it.\r\n * @param initialState The value during the first render\r\n */\r\nexport const state = Sparky__state;\r\n\r\n/**\r\n * Run and returns a memoized value\r\n * @param callbackFn - Function will be run on rendering phase\r\n * @param argumentsChanged - Array of values that the function depends on\r\n */\r\nexport const memoize = Sparky__memoize;\r\n\r\n/**\r\n * Returns routing functions for current mounted component\r\n */\r\nexport const router = Sparky__internal_history;\r\n\r\n/**\r\n * Render the html string template to HTML elements\r\n * @param html Array of HTML String \r\n * @param computedProps Computed Props used to pass Javascript into template\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\r\n */\r\nexport function html(html: TemplateStringsArray | string, ...computedProps: any[]): IRenderReturn {\r\n    const func: ISparkyEventFunc[] = [];\r\n    const nestedComponents: ISparkyComponent[] = [];\r\n    const children: IRenderReturn[] = [];\r\n    const renderId = nanoid(12);\r\n\r\n    const newHTML = (typeof html == \"string\") ? html\r\n        : html.map((stringHTML, i) => {\r\n            let htmlLine = \"\"\r\n            htmlLine += stringHTML\r\n            if (!computedProps[i]) return htmlLine;\r\n            htmlLine = getComputedValue(computedProps, i, func, htmlLine, nestedComponents, children, renderId);\r\n            return htmlLine;\r\n        })\r\n\r\n    const innerHTML = Array.isArray(newHTML) ? newHTML.join(\"\") : newHTML;\r\n\r\n    return { type: \"SparkyRender\", html: innerHTML, func, nestedComponents, children, renderId };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param computedProps \r\n * @param i \r\n * @param func \r\n * @param htmlLine \r\n * @param nestedComponents \r\n * @param children \r\n * @param renderId \r\n */\r\nfunction getComputedValue(computedProps: any[], i: number, func: ISparkyEventFunc[], htmlLine: string, nestedComponents: ISparkyComponent[], children: IRenderReturn[], renderId: string) {\r\n    if (typeof computedProps[i] == \"function\") {\r\n        func.push({ index: func.length - 1, renderId, func: computedProps[i] });\r\n        htmlLine += `'SparkyFunction#${renderId}#${func.length - 1}'`;\r\n    }\r\n    else if (computedProps[i].type == \"SparkyRender\") {\r\n        const render = computedProps[i] as IRenderReturn;\r\n        htmlLine += render.html;\r\n        children.push(render)\r\n    }\r\n    else if (computedProps[i].type == \"SparkyComponent\") {\r\n        const comp = computedProps[i] as ISparkyComponent;\r\n        htmlLine += `<!-- SparkyComponent#${comp.renderFn.name}#${nestedComponents.length}#${renderId} -->`;\r\n        nestedComponents.push(comp);\r\n    }\r\n    else {\r\n        computedProps[i] = Array.isArray(computedProps[i]) ?\r\n            computedProps[i].join(\"\") : new String(computedProps[i]);\r\n        htmlLine += computedProps[i];\r\n    }\r\n    return htmlLine;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param dom \r\n * @param element \r\n */\r\nfunction initialiseDOM(dom: HTMLElementSparkyEnhanced, element: ISparkyComponent | ISparkyRouter) {\r\n    if (dom && !dom.__sparkyRoot) {\r\n        setRootProperties(dom);\r\n        if (element.type == \"SparkyRouter\") {\r\n            const { history, routing, params, options } = element as ISparkyRouter;\r\n            dom.__sparkyRoot = { ...dom.__sparkyRoot, history, \r\n                routing, params, \r\n                basename: options?.basename, \r\n                isRoutingEnabled: true,\r\n                forceURLUpdate: options?.forceUrlUpdate,\r\n                type: options?.type\r\n            };\r\n            if(dom.__sparkyRoot.type == \"hash\") {\r\n                listeningHashChange(routing, (component) => {\r\n                    Sparky.mount(component, dom);\r\n                }, dom);                \r\n            }\r\n        }\r\n    }\r\n    ;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param dom \r\n */\r\nfunction setRootProperties(dom: HTMLElementSparkyEnhanced) {\r\n    dom.__sparkyRoot = { \r\n        id: nanoid(12),\r\n        isRoutingEnabled: false,\r\n        basename: \"\",\r\n        params: [],\r\n        forceURLUpdate: false,\r\n        type: \"hash\",\r\n        historyIndex: 0,\r\n        stateChanging: false,\r\n        history: [],\r\n        routing: [],\r\n        updateAt: null\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param html \r\n */\r\nexport function renderToDOMNode(html: string) {\r\n    const div = document.createElement(\"div\");\r\n    div.innerHTML = html;\r\n    if (div.children.length > 1) {\r\n        throw new TypeError(\"Adjacent elements on the root level are forbidden.\");\r\n    }\r\n    return div.firstElementChild as HTMLElement;\r\n}"],"names":["url","i","toString","toUpperCase","size","id","Math","random","reconciliate","currentDom","nextDom","isEqualNode","nodeName","domQueue","_a","currentElem","nextElem","removedList","attributes","sortedCurrentAttributes","Array","from","sort","attr","attr2","attributeSort","sortedNextAttributes","removedAttr","forEach","nextAttr","name","push","setAttribute","value","length","removeAttribute","reconciliateAttribute","__sparkyEvent","__sparkyRoot","nextElemChildren","childNodes","node","nextNode","item","nextElementSibling","newNextNode","cloneNode","oldNextNode","parentElement","replaceChild","parentNode","insertBefore","textContent","childNode","appendChild","rmElem","removeChild","a","b","EventManager","finalDOM","removeAllEvents","populateEvents","removeUnusedEvents","window","thisTestEvent","eventList","this","event","type","_this","isEventTypeListening","document","addEventListener","dispatchEvent","eventListType","find","evtList","isEventTarget","callbackFn","eventSingle","dom","context","elem","shift","addEvent","index","children","filter","evt","isConnected","t","target","contains","Object","prototype","val","ctorName","isArray","constructor","isBuffer","callee","err","message","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","Error","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","throw","return","next","isGeneratorObj","call","slice","toLowerCase","replace","isObjectObject","o","valueOf","Symbol","deep","typeOf","assign","Number","Map","Set","len","buf","Buffer","allocUnsafe","copy","cloneBuffer","cloneSymbol","res","byteLength","Uint8Array","set","cloneArrayBuffer","buffer","byteOffset","cloneTypedArray","exec","re","source","lastIndex","cloneRegExp","create","cloneDeep","instanceClone","ctor","prot","hasOwnProperty","key","cloneObjectDeep","cloneArrayDeep","clone","emptyContext","__rootElement","__root","__id","props","state","cachedMemo","cachedUpdate","cachedState","indexes","memo","update","renderFunc","SparkyContext","__context","newContext","ReferenceError","__defaultContext","nanoid","callCachedFn","cachedArray","argumentsChanged","fnCached","getIndexByType","newMemo","fn","result","dependencies","array1","array2","length_1","length_2","bigArray","smallArray","every","big","arrayAreSame","executeSanitizeFunction","incrementIndexByType","listeningHashChange","stateRoute","isRoutingEnabled","TypeError","requestIdleCallback","changeStateByEvent","thisTest","testing","Event","defineProperty","writable","stateChanging","basename","forceURLUpdate","documentSparky","__sparkyRoutingId","console","warn","oldURL","newURL","newState","getStateByHash","location","hash","params","getParamsByPath","path","pushToAbstractHistory","resetUpdateCache","component","newPath","exact","includes","split","pathPart","part","startsWith","join","matchUrl","sparkyRoot","historyIndex","history","Sparky_cleanHistory","Sparky__goToState","routing","routeState","normalizePath","pathname","Sparky","mount","Sparky__back","Sparky__forward","Sparky__params","Sparky__currentState","urlParts","reduce","obj","cb","start","now","setTimeout","didTimeout","timeRemaining","max","cancelIdleCallback","clearTimeout","getContext","currentContext","getCurrentContext","setCurrentState","setCurrentContext","resetIndexes","prevState","renderFn","Sparky__store","store","action","dispatcher","sparkyContext","options","locationString","element","processEnvNode","process","env","NODE_ENV","createProcessIfNotExist","time","initialiseDOM","keepIndexes","render","freeze","oldDom","updateAt","firstElementChild","nextDOM","renderToDOMNode","html","SparkyComponent","populate","getTime","listen","timeEnd","__testUtilData","root","newStore","oldNode","newNode","setRootProperties","history_1","forceUrlUpdate","div","createElement","innerHTML","rootComponent","renderQueue","depthHorizontal","currentRender","currentComponent","currentDOM","this_1","cachedComponent","func","currentFunc","currentEvent","renderId","eventAttr","index_1","findEvent","eventName","currentChild","nestedComponents","currentComp","cached","commentDom","findComment","getCachedComponent","renderChild","renderChildDOM","componentName","nodeValue","trim","i_1","dependenciesChanged","timeout","initialState","initialStore","bound","currentState","bind","setState","setInitialState","memoize","router","goToState","goBack","goAfter","getParams","cleanHistory","getCurrentState","getComputedValue","computedProps","htmlLine","comp","String","_i","newHTML","map","stringHTML"],"mappings":"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"}