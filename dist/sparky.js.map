{"version":3,"file":"sparky.js","sources":["../node_modules/nanoid/non-secure/index.js","../node_modules/mdn-polyfills/Array.from.js","../node_modules/mdn-polyfills/Array.prototype.find.js","../src/sparky.dom.ts","../src/polyfill/isConnected.ts","../src/sparky.eventmanager.ts","../node_modules/mdn-polyfills/String.prototype.startsWith.js","../src/sparky.component.ts","../src/sparky.event.ts","../src/sparky.ts","../node_modules/requestidlecallback-polyfill/index.js","../src/sparky.function.ts","../src/sparky.helper.ts","../src/sparky.ts"],"sourcesContent":["// This alphabet uses a-z A-Z 0-9 _- symbols.\n// Symbols are generated for smaller size.\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\nvar url = '-_'\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\nvar i = 36\nwhile (i--) {\n  // 36 is radix. Number.prototype.toString(36) returns number\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\n  url += i.toString(36)\n}\n// Loop from 36 to 10 (from Z to A in Base36).\ni = 36\nwhile (i-- - 10) {\n  url += i.toString(36).toUpperCase()\n}\n\n/**\n * Generate URL-friendly unique ID. This method use non-secure predictable\n * random generator with bigger collision probability.\n *\n * @param {number} [size=21] The number of symbols in ID.\n *\n * @return {string} Random string.\n *\n * @example\n * const nanoid = require('nanoid/non-secure')\n * model.id = nanoid() //=> \"Uakgb_J5m9g-0JDMbcJqL\"\n *\n * @name nonSecure\n * @function\n */\nmodule.exports = function (size) {\n  var id = ''\n  i = size || 21\n  // Compact alternative for `for (var i = 0; i < size; i++)`\n  while (i--) {\n    // `| 0` is compact and faster alternative for `Math.floor()`\n    id += url[Math.random() * 64 | 0]\n  }\n  return id\n}\n","!function(){var t,u,e,c;Array.from||(Array.from=(t=Object.prototype.toString,u=function(r){return\"function\"==typeof r||\"[object Function]\"===t.call(r)},e=Math.pow(2,53)-1,c=function(r){var t,n=(t=Number(r),isNaN(t)?0:0!==t&&isFinite(t)?(0<t?1:-1)*Math.floor(Math.abs(t)):t);return Math.min(Math.max(n,0),e)},function(r){var t=Object(r);if(null==r)throw new TypeError(\"Array.from requires an array-like object - not null or undefined\");var n,e=1<arguments.length?arguments[1]:void 0;if(void 0!==e){if(!u(e))throw new TypeError(\"Array.from: when provided, the second argument must be a function\");2<arguments.length&&(n=arguments[2])}for(var o,a=c(t.length),i=u(this)?Object(new this(a)):new Array(a),f=0;f<a;)o=t[f],i[f]=e?void 0===n?e(o,f):e.call(n,o,f):o,f+=1;return i.length=a,i}))}();\n","Array.prototype.find||(Array.prototype.find=function(r){if(null==this)throw new TypeError(\"Array.prototype.find called on null or undefined\");if(\"function\"!=typeof r)throw new TypeError(\"predicate must be a function\");for(var t=Object(this),n=t.length>>>0,o=arguments[1],e=void 0,i=0;i<n;i++)if(e=t[i],r.call(o,e,i,t))return e});\n","let currentDom: HTMLElement = null;\r\n\r\nexport function getCurrentDom() {\r\n    return currentDom;\r\n}\r\n\r\nexport function setCurrentDom(dom: HTMLElement) {\r\n    currentDom = dom;\r\n}\r\n\r\nexport function reconciliate(currentDom: HTMLElement, nextDom: HTMLElement) {\r\n    if (!nextDom) return null;\r\n    if (!currentDom && nextDom) return nextDom;\r\n    if (currentDom.isEqualNode(nextDom)) return currentDom;\r\n    if (currentDom.nodeName !== nextDom.nodeName) return nextDom;\r\n\r\n    const domQueue: [Node, Node][] = [[currentDom, nextDom]];\r\n\r\n    while(domQueue.length > 0) {\r\n        const [currentElem, nextElem] = domQueue.shift();\r\n        const removedList: Node[] = [];\r\n        reconciliateAttribute(currentElem as HTMLElement, nextElem as HTMLElement);\r\n\r\n        const nextElemChildren = nextElem.childNodes;\r\n        currentElem.childNodes.forEach((node, i) => {\r\n            const nextNode = nextElemChildren.item(i);\r\n\r\n            if(!nextNode) {\r\n                removedList.push(node)\r\n                return;\r\n            }\r\n\r\n            if(node.isEqualNode(nextNode)) return;\r\n\r\n            if(node.nodeName !== nextNode.nodeName) {\r\n                currentElem.replaceChild(nextNode.cloneNode(true), node);\r\n                return;\r\n            }\r\n\r\n            if(node.nodeName == \"#text\" && node.textContent !== nextNode.textContent) {\r\n                node.textContent = nextNode.textContent;\r\n                return;\r\n            }\r\n\r\n            domQueue.push([node, nextNode])\r\n        });\r\n\r\n        for(let i = currentElem.childNodes.length; i < nextElem.childNodes.length; i++) {\r\n            const childNode = nextElem.childNodes.item(i);\r\n            currentElem.appendChild(childNode.cloneNode(true))\r\n        }\r\n\r\n        removedList.forEach((rmElem) => {\r\n            currentElem.removeChild(rmElem)\r\n        })\r\n\r\n    }\r\n\r\n    return currentDom;\r\n}\r\n\r\nfunction reconciliateAttribute(currentElem: HTMLElement, nextElem: HTMLElement) {\r\n    if(!currentElem.attributes || !nextElem.attributes) return;\r\n\r\n    const sortedCurrentAttributes = Array.from(currentElem.attributes).sort((attr, attr2) => attributeSort(attr, attr2))\r\n    const sortedNextAttributes = Array.from(nextElem.attributes).sort((attr, attr2) => attributeSort(attr, attr2))\r\n\r\n    const removedAttr: Attr[] = [];\r\n\r\n    sortedCurrentAttributes.forEach((attr, i) => {\r\n        const nextAttr = sortedNextAttributes[i];\r\n\r\n        if(!nextAttr) {\r\n            removedAttr.push(attr);\r\n            return;\r\n        }\r\n        \r\n        if(attr.name !== nextAttr.name) {\r\n            removedAttr.push(attr);\r\n            currentElem.setAttribute(nextAttr.name, nextAttr.value);\r\n            return;\r\n        }\r\n\r\n        if(attr.value !== nextAttr.value) {\r\n            attr.value = nextAttr.value;\r\n        }\r\n    })\r\n\r\n    for(let i = sortedCurrentAttributes.length; i < sortedNextAttributes.length; i++) {\r\n        const nextAttr = sortedNextAttributes[i];\r\n        currentElem.setAttribute(nextAttr.name, nextAttr.value);\r\n    }\r\n\r\n    removedAttr.forEach(attr => currentElem.removeAttribute(attr.name))\r\n}\r\n\r\nfunction attributeSort(a: Attr, b: Attr) {\r\n    return (a.name < b.name ? -1 : (a.name > b.name ? 1 : 0));\r\n}\r\n","/*\r\n * Node.isConnected polyfill for IE and EdgeHTML\r\n * 2020-02-04\r\n *\r\n * By Eli Grey, https://eligrey.com\r\n * Public domain.\r\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\r\n */\r\nexport function isConnectedPolyfill() {\r\n    if (!('isConnected' in Node.prototype)) {\r\n        Object.defineProperty(Node.prototype, 'isConnected', {\r\n        get() {\r\n            return (\r\n            !this.ownerDocument ||\r\n            !(\r\n                this.ownerDocument.compareDocumentPosition(this) &\r\n                this.DOCUMENT_POSITION_DISCONNECTED\r\n            )\r\n            );\r\n        },\r\n        });\r\n    }    \r\n}\r\n","import { isConnectedPolyfill } from \"./polyfill/isConnected\"\r\n\r\nisConnectedPolyfill();\r\n\r\ninterface eventListSingle {\r\n    dom: HTMLElement;\r\n    type: string;\r\n    callbackFn: eventCallbackFn;\r\n}\r\n\r\ntype eventCallbackFn = (evt: Event) => void;\r\n\r\nexport class EventManager {\r\n    static oldEventType: string[] = [];\r\n    static eventList: eventListSingle[] = [];\r\n    static eventListType: string[] = [];\r\n\r\n    static listen() {\r\n        EventManager.removeUnusedEvents();\r\n        this.eventList.forEach((event) => {\r\n            const { type } = event;\r\n            if(!this.isEventTypeListening(type)) {\r\n                document.addEventListener(type, (event) => this.dispatchEvent(event))\r\n                this.eventListType.push(type);\r\n            }\r\n        });\r\n    }\r\n\r\n    static dispatchEvent(event: Event) {\r\n        this.eventList.find((evtList) => {\r\n            if(this.isEventTarget(evtList, event)) {\r\n                if(evtList.type === event.type) {\r\n                    evtList.callbackFn(event);\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    static addEvent(eventSingle: eventListSingle) {\r\n        const {dom, type, callbackFn} = eventSingle;\r\n        this.eventList.push({ dom, type, callbackFn });\r\n    }\r\n\r\n    private static removeUnusedEvents() {\r\n        this.eventList = this.eventList\r\n            .filter((evt) => evt.dom.isConnected);\r\n    }\r\n\r\n    private static isEventTypeListening(type: string) {\r\n        return this.eventListType.find(t => t == type);\r\n    }\r\n\r\n    private static isEventTarget(evtList: eventListSingle, event: Event) {\r\n        return (evtList.dom === event.target) || evtList.dom.contains(event.target as HTMLElement);\r\n    }\r\n}","String.prototype.startsWith||(String.prototype.startsWith=function(t,r){return r=r||0,this.substr(r,t.length)===t});\n","import { IRenderReturn, ISparkyComponent } from \"./sparky\";\r\nimport { findEvent } from \"./sparky.event\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\n\r\ninterface ICachedComponent {\r\n    component: ISparkyComponent,\r\n    dom: HTMLElement\r\n}\r\n\r\nexport class SparkyComponent {\r\n    private static cachedComponent: ICachedComponent[][] = [];\r\n    static populate(render: IRenderReturn, rootComponent: ISparkyComponent) {\r\n        \r\n        const renderQueue = [render];\r\n\r\n        let depthHorizontal = 0;\r\n\r\n        while (renderQueue.length > 0) {\r\n            const currentRender = renderQueue.shift();\r\n            if(!this.cachedComponent[depthHorizontal]) this.cachedComponent[depthHorizontal] = [];\r\n\r\n            currentRender.func.forEach((currentFunc, index) => {\r\n                const currentEvent = findEvent(render.dom, currentRender.renderId, index);\r\n                const eventName = currentEvent.attr.name.replace(\"on\", \"\");\r\n                EventManager.addEvent({\r\n                    dom: currentEvent.dom,\r\n                    type: eventName,\r\n                    callbackFn: currentFunc.func.bind(window, event)\r\n                })\r\n                currentEvent.dom.removeAttribute(currentEvent.attr.name)\r\n            })\r\n\r\n            currentRender.children.forEach((currentChild) => {\r\n                renderQueue.push(currentChild)\r\n            })\r\n\r\n            currentRender.nestedComponents.forEach((currentComp, index) => {\r\n                if(currentComp.type !== \"SparkyComponent\") return;\r\n                const cached = this.cachedComponent[depthHorizontal][index];\r\n                const commentDom = this.findComment(render.dom, currentRender.renderId, index, currentComp.selfFn.name);\r\n                if(cached) {\r\n                    cached.component.self.props = currentComp.self.props;\r\n                    currentComp = cached.component;\r\n                }\r\n                const renderChild = currentComp.selfFn(currentComp.self, Object.freeze(currentComp.self.props));\r\n                if(!commentDom) return;\r\n                commentDom.parentNode.replaceChild(renderChild.dom, commentDom);\r\n                currentComp.self.__root = rootComponent;\r\n                render.func.push(...renderChild.func);\r\n                renderQueue.push(renderChild);\r\n\r\n                this.cachedComponent[depthHorizontal].push({\r\n                    component: currentComp,\r\n                    dom: renderChild.dom\r\n                })\r\n            });\r\n            depthHorizontal++;\r\n        }\r\n\r\n        return render.dom;\r\n    }\r\n\r\n    private static findComment(element: HTMLElement, renderId: string, i: number, componentName: string) {\r\n        const domQueue = [element];\r\n        while(domQueue.length > 0) {\r\n            const elem = domQueue.shift();\r\n            if(elem.nodeName == '#comment' && elem.nodeValue.trim() == `SparkyComponent#${componentName}#${i}#${renderId}`) {\r\n                return elem;\r\n            }\r\n\r\n            Array.from(elem.childNodes as NodeListOf<HTMLElement>).forEach((child) => {\r\n                domQueue.push(child)\r\n            })\r\n        }\r\n    }\r\n}","import 'mdn-polyfills/String.prototype.startsWith';\r\n\r\ninterface IEventReturn {\r\n    dom: HTMLElement;\r\n    attr: Attr;\r\n}\r\n\r\nexport function findEvent(element: HTMLElement, renderId: string, index: number) : IEventReturn {\r\n    const domQueue = [element];\r\n    while(domQueue.length > 0) {\r\n        const elem = domQueue.shift();\r\n        const eventAttr = Array.from(elem.attributes).find((attr) => {\r\n            if(attr.name.startsWith(\"on\")) {\r\n                return attr.value == `SparkyFunction#${renderId}#${index}`;\r\n            }\r\n        })\r\n\r\n        if(eventAttr) return {dom: elem, attr: eventAttr};\r\n        \r\n        Array.from(elem.children as HTMLCollectionOf<HTMLElement>).forEach((child) => {\r\n            domQueue.push(child)\r\n        })\r\n    }\r\n}","import nanoid from \"nanoid/non-secure\";\r\n\r\nimport 'mdn-polyfills/Array.from';\r\nimport 'mdn-polyfills/Array.prototype.find';\r\n\r\nimport { SparkyFunction } from \"./sparky.function\";\r\nimport { reconciliate, getCurrentDom, setCurrentDom } from \"./sparky.dom\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { SparkyComponent } from \"./sparky.component\";\r\n\r\nimport { isConnectedPolyfill } from \"./polyfill/isConnected\"\r\n\r\nisConnectedPolyfill();\r\n\r\nexport interface IRenderReturn extends IReconciliateProps {\r\n    type: string;\r\n    nestedComponents: ISparkyComponent[];\r\n    children: IRenderReturn[];\r\n    renderId: string;\r\n}\r\n\r\nexport interface IReconciliateProps {\r\n    dom: HTMLElement,\r\n    func: ISparkyEventFunc[],\r\n}\r\n\r\nexport type ISelfFunction = (self: SparkyFunction, props?: any) => IRenderReturn;\r\n\r\nexport interface ISparkyEventFunc {\r\n    renderId: string;\r\n    index: number;\r\n    func: Function;\r\n}\r\n\r\nexport interface ISparkyComponent {\r\n    type: string;\r\n    self: SparkyFunction;\r\n    selfFn: ISelfFunction;\r\n}\r\n\r\nexport interface ISparkyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport type ISparkyState = ISparkyProps;\r\n\r\nexport class Sparky {\r\n    public static _DEV_: boolean = true;\r\n\r\n    /**\r\n     * Generate a Sparky Component that can be mount.\r\n     * @param renderFunc The function that going to be execute to render html template\r\n     */\r\n    static component(renderFunc: ISelfFunction, props?: ISparkyProps) {\r\n        const thisFunction = new SparkyFunction(renderFunc, props);\r\n        return { type: \"SparkyComponent\", self: thisFunction, selfFn: renderFunc } as ISparkyComponent;\r\n    }\r\n\r\n    /**\r\n     * Mount a Sparky Component in the DOM Tree and keep it updated.\r\n     * @param component Sparky Component\r\n     * @param dom The dom element where you want to mount this component\r\n     */\r\n    static mount(component: ISparkyComponent, dom?: HTMLElement) {\r\n        if(Sparky._DEV_)\r\n            console.time();\r\n        \r\n        const { self, selfFn } = component;\r\n        const render = selfFn.call(window, self, Object.freeze(self.props)) as IRenderReturn;\r\n\r\n        render.dom = SparkyComponent.populate(render, component);\r\n\r\n        let finalDOM = reconciliate(getCurrentDom(), render.dom);           \r\n        if (!finalDOM) return;\r\n        if (!finalDOM.isConnected && dom)\r\n            dom.appendChild(finalDOM);\r\n        EventManager.listen();\r\n        \r\n        setCurrentDom(finalDOM as HTMLElement);\r\n        \r\n        if(Sparky._DEV_)\r\n            console.timeEnd();\r\n    }\r\n\r\n    /**\r\n     * Reconciliate the current DOM with the new DOM Node\r\n     * @param oldNode Node that need to be reconcile\r\n     * @param newNode Node that have the new elements\r\n     */\r\n    static reconciliate(oldNode: HTMLElement, newNode: HTMLElement) {\r\n        return reconciliate(oldNode, newNode)\r\n    }\r\n}\r\n\r\n/**\r\n * Render the html string template to HTML elements\r\n * @param html Array of HTML String \r\n * @param computedProps Computed Props used to pass Javascript into template\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\r\n */\r\nexport function render(html: TemplateStringsArray | string, ...computedProps: any[]): IRenderReturn {\r\n    const domNode = document.createElement(\"div\");\r\n    const func: ISparkyEventFunc[] = [];\r\n    const nestedComponents: ISparkyComponent[] = [];\r\n    const children: IRenderReturn[] = [];\r\n    const renderId = nanoid(12);\r\n\r\n    const newHTML = (typeof html == \"string\") ? html\r\n        : html.map((stringHTML, i) => {\r\n            let htmlLine = \"\"\r\n            htmlLine += stringHTML\r\n            if(!computedProps[i]) return htmlLine;\r\n            htmlLine = getComputedValue(computedProps, i, func, htmlLine, nestedComponents, children, renderId);\r\n            return htmlLine;\r\n        })\r\n        \r\n    domNode.innerHTML = Array.isArray(newHTML) ? newHTML.join(\"\") : newHTML;\r\n\r\n    if(domNode.children.length > 1) {\r\n        throw new TypeError(\"The render HTML can only had one root node\");\r\n    }\r\n\r\n    return { type: \"SparkyRender\", dom: domNode.firstElementChild as HTMLElement, func, nestedComponents, children, renderId };\r\n}\r\n\r\nfunction getComputedValue(computedProps: any[], i: number, func: ISparkyEventFunc[], htmlLine: string, nestedComponents: ISparkyComponent[], children: IRenderReturn[], renderId: string) {\r\n    if (typeof computedProps[i] == \"function\") {\r\n        func.push({index: func.length - 1, renderId, func: computedProps[i]});\r\n        htmlLine += `'SparkyFunction#${renderId}#${func.length - 1}'`;\r\n    }\r\n    else if (computedProps[i].type == \"SparkyRender\") {\r\n        const render = computedProps[i] as IRenderReturn;\r\n        htmlLine = renderSparkyObject(render, htmlLine);\r\n        children.push(render)\r\n    }\r\n    else if (computedProps[i].type == \"SparkyComponent\") {\r\n        const comp = computedProps[i] as ISparkyComponent;\r\n        htmlLine += `<!-- SparkyComponent#${comp.selfFn.name}#${nestedComponents.length}#${renderId} -->`;\r\n        nestedComponents.push(comp);\r\n    }\r\n    else {\r\n\r\n        computedProps[i] = Array.isArray(computedProps[i]) ? \r\n            computedProps[i].join(\"\") : new String(computedProps[i]);\r\n        if ((computedProps[i] as string).startsWith(\"<\"))\r\n            htmlLine += computedProps[i];\r\n        else\r\n            htmlLine += `<span class='computed'>${computedProps[i]}</span>`;\r\n    }\r\n    return htmlLine;\r\n}\r\n\r\nfunction renderSparkyObject(render: IRenderReturn, htmlLine: string) {\r\n    const div = document.createElement(\"div\");\r\n    div.appendChild(render.dom);\r\n    htmlLine += div.innerHTML;\r\n    return htmlLine;\r\n}\r\n","window.requestIdleCallback =\n    window.requestIdleCallback ||\n    function(cb) {\n        var start = Date.now();\n        return setTimeout(function() {\n            cb({\n                didTimeout: false,\n                timeRemaining: function() {\n                    return Math.max(0, 50 - (Date.now() - start));\n                },\n            });\n        }, 1);\n    };\n\nwindow.cancelIdleCallback =\n    window.cancelIdleCallback ||\n    function(id) {\n        clearTimeout(id);\n    };\n","import { Sparky, IRenderReturn, ISparkyComponent, ISparkyProps, ISparkyState } from \"./sparky\";\r\nimport 'requestidlecallback-polyfill';\r\nimport { arrayAreSame } from \"./sparky.helper\";\r\n\r\ntype UpdateCallback = () => void;\r\n\r\ntype DependenciesList = string[];\r\ntype ArgumentsList = any[];\r\n\r\ninterface IMemoCached {\r\n    fn: Function;\r\n    dependencies: string[];\r\n    result: any;\r\n}\r\n\r\nexport class SparkyFunction {\r\n    public __root: ISparkyComponent;\r\n    public props: ISparkyProps;\r\n    \r\n    private newProps: string[] = [];\r\n    private cachedMemo: IMemoCached[] = [];\r\n    private state: ISparkyState;\r\n    private renderFunc: (self: SparkyFunction) => IRenderReturn;\r\n\r\n    constructor(renderFunc: (self: SparkyFunction) => IRenderReturn, props: ISparkyProps) {\r\n        this.props = Object.freeze(props || {});\r\n        this.state = {};\r\n        this.renderFunc = renderFunc;\r\n        this.__root = null;\r\n    }\r\n    \r\n    /**\r\n     * Execute after the render/update of the DOM tree.\r\n     * @param callback - The function that you want to execute\r\n     * @param dependenciesChanged - An array of keys to know when the onUpdate need to be executed\r\n     */\r\n    onUpdate = (callback: UpdateCallback, dependenciesChanged?: DependenciesList) => {\r\n        if (!dependenciesChanged && this.newProps.length == 0 ||\r\n            dependenciesChanged && dependenciesChanged.length == 0 ||\r\n            this.newProps.some((props) => dependenciesChanged && dependenciesChanged.includes(props)))\r\n            //@ts-ignore\r\n            window.requestIdleCallback(() => callback.call(this))\r\n    }\r\n\r\n    /**\r\n    * Get State object value of this context\r\n    * @param props - the specific key of the value that you want to retrieve\r\n    */\r\n    getState = <S>(props: string): S => {\r\n        if (props) return this.state[props];\r\n        return this.state as S;\r\n    }\r\n\r\n    /**\r\n     * Add/Set a new value into the State object of the context\r\n     * @param newState - new Value\r\n     */\r\n    setState = <S>(newState: S) => {\r\n        this.newProps = Object.keys(newState);\r\n        this.state = { ...this.state, ...newState };\r\n        (this.__root) ? Sparky.mount(this.__root) :\r\n            Sparky.mount({ type: \"SparkyComponent\", self: this, selfFn: this.renderFunc });\r\n    }\r\n\r\n    /**\r\n     * Call the function callback only when dependencies has changed\r\n     * @param callbackFn - Callback to be called when needed\r\n     * @param argumentsChanged - list of value that are used to know if the callback needed to be recalled\r\n     */\r\n    memo = (callbackFn: Function, argumentsChanged?: ArgumentsList) => {\r\n        const memoCached = this.cachedMemo.find((memo) => callbackFn.toString() == memo.fn.toString());\r\n        const newMemo = {\r\n            fn: callbackFn,\r\n            result: null,\r\n            dependencies: argumentsChanged\r\n        };\r\n\r\n        if(!memoCached) {\r\n            newMemo.result = callbackFn.call(window, ...argumentsChanged);\r\n            this.cachedMemo.push(newMemo)\r\n            return newMemo.result;\r\n        }\r\n        \r\n        if(!arrayAreSame(memoCached.dependencies, argumentsChanged)) {\r\n            memoCached.dependencies = argumentsChanged;\r\n            return callbackFn.call(window, ...argumentsChanged)\r\n        }\r\n        \r\n        return memoCached.result;\r\n    }\r\n}","interface ISortArray {\r\n    bigArray: any[];\r\n    smallArray: any[];\r\n}\r\n\r\nexport function arrayAreSame(array1: any[], array2: any[]) {\r\n    const { bigArray, smallArray } = sortArrayInObject(array1, array2);\r\n\r\n    return bigArray.every((big, i) => {\r\n        return big == (smallArray ? smallArray[i] : null);\r\n    })\r\n}\r\n\r\nfunction sortArrayInObject(array1: any[], array2: any[]): ISortArray {\r\n    const length_1 = array1.length;\r\n    const length_2 = array2.length;\r\n\r\n    if(length_1 > length_2) return { bigArray: array1, smallArray: array2 }\r\n\r\n    return { bigArray: array2, smallArray: array1 }\r\n}","import nanoid from \"nanoid/non-secure\";\r\n\r\nimport 'mdn-polyfills/Array.from';\r\nimport 'mdn-polyfills/Array.prototype.find';\r\n\r\nimport { SparkyFunction } from \"./sparky.function\";\r\nimport { reconciliate, getCurrentDom, setCurrentDom } from \"./sparky.dom\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { SparkyComponent } from \"./sparky.component\";\r\n\r\nimport { isConnectedPolyfill } from \"./polyfill/isConnected\"\r\n\r\nisConnectedPolyfill();\r\n\r\nexport interface IRenderReturn extends IReconciliateProps {\r\n    type: string;\r\n    nestedComponents: ISparkyComponent[];\r\n    children: IRenderReturn[];\r\n    renderId: string;\r\n}\r\n\r\nexport interface IReconciliateProps {\r\n    dom: HTMLElement,\r\n    func: ISparkyEventFunc[],\r\n}\r\n\r\nexport type ISelfFunction = (self: SparkyFunction, props?: any) => IRenderReturn;\r\n\r\nexport interface ISparkyEventFunc {\r\n    renderId: string;\r\n    index: number;\r\n    func: Function;\r\n}\r\n\r\nexport interface ISparkyComponent {\r\n    type: string;\r\n    self: SparkyFunction;\r\n    selfFn: ISelfFunction;\r\n}\r\n\r\nexport interface ISparkyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport type ISparkyState = ISparkyProps;\r\n\r\nexport class Sparky {\r\n    public static _DEV_: boolean = true;\r\n\r\n    /**\r\n     * Generate a Sparky Component that can be mount.\r\n     * @param renderFunc The function that going to be execute to render html template\r\n     */\r\n    static component(renderFunc: ISelfFunction, props?: ISparkyProps) {\r\n        const thisFunction = new SparkyFunction(renderFunc, props);\r\n        return { type: \"SparkyComponent\", self: thisFunction, selfFn: renderFunc } as ISparkyComponent;\r\n    }\r\n\r\n    /**\r\n     * Mount a Sparky Component in the DOM Tree and keep it updated.\r\n     * @param component Sparky Component\r\n     * @param dom The dom element where you want to mount this component\r\n     */\r\n    static mount(component: ISparkyComponent, dom?: HTMLElement) {\r\n        if(Sparky._DEV_)\r\n            console.time();\r\n        \r\n        const { self, selfFn } = component;\r\n        const render = selfFn.call(window, self, Object.freeze(self.props)) as IRenderReturn;\r\n\r\n        render.dom = SparkyComponent.populate(render, component);\r\n\r\n        let finalDOM = reconciliate(getCurrentDom(), render.dom);           \r\n        if (!finalDOM) return;\r\n        if (!finalDOM.isConnected && dom)\r\n            dom.appendChild(finalDOM);\r\n        EventManager.listen();\r\n        \r\n        setCurrentDom(finalDOM as HTMLElement);\r\n        \r\n        if(Sparky._DEV_)\r\n            console.timeEnd();\r\n    }\r\n\r\n    /**\r\n     * Reconciliate the current DOM with the new DOM Node\r\n     * @param oldNode Node that need to be reconcile\r\n     * @param newNode Node that have the new elements\r\n     */\r\n    static reconciliate(oldNode: HTMLElement, newNode: HTMLElement) {\r\n        return reconciliate(oldNode, newNode)\r\n    }\r\n}\r\n\r\n/**\r\n * Render the html string template to HTML elements\r\n * @param html Array of HTML String \r\n * @param computedProps Computed Props used to pass Javascript into template\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\r\n */\r\nexport function render(html: TemplateStringsArray | string, ...computedProps: any[]): IRenderReturn {\r\n    const domNode = document.createElement(\"div\");\r\n    const func: ISparkyEventFunc[] = [];\r\n    const nestedComponents: ISparkyComponent[] = [];\r\n    const children: IRenderReturn[] = [];\r\n    const renderId = nanoid(12);\r\n\r\n    const newHTML = (typeof html == \"string\") ? html\r\n        : html.map((stringHTML, i) => {\r\n            let htmlLine = \"\"\r\n            htmlLine += stringHTML\r\n            if(!computedProps[i]) return htmlLine;\r\n            htmlLine = getComputedValue(computedProps, i, func, htmlLine, nestedComponents, children, renderId);\r\n            return htmlLine;\r\n        })\r\n        \r\n    domNode.innerHTML = Array.isArray(newHTML) ? newHTML.join(\"\") : newHTML;\r\n\r\n    if(domNode.children.length > 1) {\r\n        throw new TypeError(\"The render HTML can only had one root node\");\r\n    }\r\n\r\n    return { type: \"SparkyRender\", dom: domNode.firstElementChild as HTMLElement, func, nestedComponents, children, renderId };\r\n}\r\n\r\nfunction getComputedValue(computedProps: any[], i: number, func: ISparkyEventFunc[], htmlLine: string, nestedComponents: ISparkyComponent[], children: IRenderReturn[], renderId: string) {\r\n    if (typeof computedProps[i] == \"function\") {\r\n        func.push({index: func.length - 1, renderId, func: computedProps[i]});\r\n        htmlLine += `'SparkyFunction#${renderId}#${func.length - 1}'`;\r\n    }\r\n    else if (computedProps[i].type == \"SparkyRender\") {\r\n        const render = computedProps[i] as IRenderReturn;\r\n        htmlLine = renderSparkyObject(render, htmlLine);\r\n        children.push(render)\r\n    }\r\n    else if (computedProps[i].type == \"SparkyComponent\") {\r\n        const comp = computedProps[i] as ISparkyComponent;\r\n        htmlLine += `<!-- SparkyComponent#${comp.selfFn.name}#${nestedComponents.length}#${renderId} -->`;\r\n        nestedComponents.push(comp);\r\n    }\r\n    else {\r\n\r\n        computedProps[i] = Array.isArray(computedProps[i]) ? \r\n            computedProps[i].join(\"\") : new String(computedProps[i]);\r\n        if ((computedProps[i] as string).startsWith(\"<\"))\r\n            htmlLine += computedProps[i];\r\n        else\r\n            htmlLine += `<span class='computed'>${computedProps[i]}</span>`;\r\n    }\r\n    return htmlLine;\r\n}\r\n\r\nfunction renderSparkyObject(render: IRenderReturn, htmlLine: string) {\r\n    const div = document.createElement(\"div\");\r\n    div.appendChild(render.dom);\r\n    htmlLine += div.innerHTML;\r\n    return htmlLine;\r\n}\r\n"],"names":["url","i","toString","toUpperCase","t","u","e","c","Array","from","Object","prototype","r","call","Math","pow","n","Number","isNaN","isFinite","floor","abs","min","max","TypeError","arguments","length","o","a","this","f","find","currentDom","getCurrentDom","setCurrentDom","dom","reconciliate","nextDom","isEqualNode","nodeName","domQueue","_a","currentElem","nextElem","removedList","attributes","sortedCurrentAttributes","sort","attr","attr2","attributeSort","sortedNextAttributes","removedAttr","forEach","nextAttr","name","push","setAttribute","value","removeAttribute","reconciliateAttribute","nextElemChildren","childNodes","node","nextNode","item","textContent","replaceChild","cloneNode","childNode","appendChild","rmElem","removeChild","b","isConnectedPolyfill","Node","defineProperty","get","ownerDocument","compareDocumentPosition","DOCUMENT_POSITION_DISCONNECTED","EventManager","removeUnusedEvents","eventList","event","type","_this","isEventTypeListening","document","addEventListener","dispatchEvent","eventListType","evtList","isEventTarget","callbackFn","eventSingle","filter","evt","isConnected","target","contains","String","startsWith","substr","SparkyComponent","render","rootComponent","renderQueue","depthHorizontal","currentRender","shift","this_1","cachedComponent","func","currentFunc","index","currentEvent","element","renderId","elem","eventAttr","children","child","findEvent","eventName","replace","addEvent","bind","window","currentChild","nestedComponents","currentComp","cached","commentDom","findComment","selfFn","component","self","props","renderChild","freeze","parentNode","__root","componentName","nodeValue","trim","Sparky","renderFunc","SparkyFunction","_DEV_","console","time","populate","finalDOM","listen","timeEnd","oldNode","newNode","requestIdleCallback","cb","start","Date","now","setTimeout","didTimeout","timeRemaining","cancelIdleCallback","id","clearTimeout","callback","dependenciesChanged","newProps","some","includes","state","newState","keys","mount","argumentsChanged","array1","array2","length_1","smallArray","memoCached","cachedMemo","memo","fn","newMemo","result","dependencies","bigArray","every","big","html","_i","computedProps","domNode","createElement","size","random","nanoid","newHTML","map","stringHTML","htmlLine","render_1","div","innerHTML","renderSparkyObject","comp","isArray","join","getComputedValue","firstElementChild"],"mappings":"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"}